const TryOnHelper = function() { const u = { cameraMinVideoDimFov: 38, debugObjPoints: 0 }; var o = { leftEyeCtr: [33.7, 37.9, 45.9], rightEyeCtr: [-33.7, 37.9, 45.9], leftEyeInt: [16, 36, 40], rightEyeInt: [-16, 36, 40], leftEyeExt: [42, 34, 38], rightEyeExt: [-42, 34, 38], leftEyeBot: [33, 31, 45], rightEyeBot: [-33, 31, 45], leftEarBottom: [70, -18.6, -18], rightEarBottom: [-70, -18.6, -18], leftEarEarring: [75, -37, -24.8], rightEarEarring: [-75, -37, -24.8], noseLeft: [21, -.1, 67], noseRight: [-21, -.1, 67], noseBottom: [0, -.6, 82], noseOuter: [0, 16, 93], mouthLeft: [27, -29.9, 70.8], mouthRight: [-27, -29.9, 70.8], upperLipBot: [0, -24, 83.5], upperLipTop: [0, -17.2, 86.3], lowerLipTop: [0, -26, 84.3], lowerLipBot: [0, -34, 89.6], leftEyeBrowInt: [15, 55.4, 51.2], rightEyeBrowInt: [-15, 55.4, 51.2], templeTopRight: [-66, 39, 11.5], templeTopLeft: [66, 39, 11.5], templeBotRight: [-69.5, 7, 21], templeBotLeft: [69.5, 7, 21], chin: [0, -71, 91], chinTop: [0, -60, 95], chinLeft: [31, -60, 76], chinRight: [-31, -60, 76] },
        n = ["chin", "leftEarBottom", "rightEarBottom", "noseOuter", "leftEyeExt", "rightEyeExt"]; const d = Math.PI / 180; let m = -1,
        l = null,
        r = null; const a = { copy: null }; let i = null,
        s = null,
        c = null,
        f = null,
        p = null; const v = [0, 0],
        E = { labels: null, indices: {} },
        h = { objPoints: [], objPointsMean: null, imgPointsLMIndices: [], imgPointsPx: [] },
        P = { isPostProcessing: !1, taaLevel: 0, canvas: null, renderer: null, composer: null, scene: null, camera: null, faceSlots: [], matMov: null, matMov2: null, euler: null, vec3: null, preMatrix: null }; let g = !0; var e = window.devicePixelRatio || 1;

    function R(e, t, o) { t = i.createShader(t); return i.shaderSource(t, e), i.compileShader(t), i.getShaderParameter(t, i.COMPILE_STATUS) ? t : (alert("ERROR IN " + o + " SHADER: " + i.getShaderInfoLog(t)), null) }

    function w() { var e = .5 * m * d,
            e = .5 * M.get_viewHeight() / Math.tan(e);
        v[0] = e, v[1] = e }

    function T(t, o) { const n = []; for (let e = 0; e < t.length; ++e) n.push([0, 0]); if (h.imgPointsPx = n, h.imgPointsLMIndices = t.map(function(e) { var t = E.labels.indexOf(e); if (-1 === t) throw new Error("This neuron network model does not have any point with label=" + e); return t }), h.objPoints = t.map(function(e) { return o[e].slice(0) }), l.isCenterObjPoints) { const r = [0, 0, 0];
            h.objPoints.forEach(function(e) { r[0] += e[0], r[1] += e[1], r[2] += e[2] }); var e = h.objPoints.length;
            r[0] /= e, r[1] /= e, r[2] /= e, h.objPointsMean = r, h.objPoints.forEach(function(e) { e[0] -= r[0], e[1] -= r[1], e[2] -= r[2] }) } }

    function b(e, t) { e ? l.callbackReady && l.callbackReady(e, null) : (window.addEventListener("focus", M.reset_stabilizers), i = t.GL, s = t.canvasElement, c = t.videoTexture, f = t.videoTransformMat2, E.labels = t.landmarksLabels, p = t.video, E.labels.forEach(function(e, t) { E.indices[e] = t }), r = "undefined" == typeof TryOnStabilizer ? null : [], a.copyCrop = function(e, t, o) { return e = R(e, i.VERTEX_SHADER, "VERTEX " + o), t = R("precision lowp float;" + t, i.FRAGMENT_SHADER, "FRAGMENT " + o), o = i.createProgram(), i.attachShader(o, e), i.attachShader(o, t), i.linkProgram(o), t = i.getAttribLocation(o, "position"), i.enableVertexAttribArray(t), { program: o, uniforms: {} } }("attribute vec2 position;\n      uniform mat2 transform;\n      varying vec2 vUV;\n      void main(void){\n        vUV = 0.5 + transform * position;\n        gl_Position = vec4(position, 0., 1.);\n      }", "uniform sampler2D uun_source;\n      varying vec2 vUV;\n      void main(void){\n        gl_FragColor = texture2D(uun_source, vUV);\n      }", "COPY CROP"), a.copyCrop.uniforms.transformMat2 = i.getUniformLocation(a.copyCrop.program, "transform"), function(t) { if (P.canvas = l.canvasThree, P.isPostProcessing = l.isPostProcessing, P.taaLevel = l.taaLevel, 0 < P.taaLevel && (P.isPostProcessing = !0), P.renderer = new THREE.WebGLRenderer({ canvas: P.canvas, alpha: !0, antialias: !0, preserveDrawingBuffer: !0 }), P.renderer.setClearAlpha(0), P.scene = new THREE.Scene, P.camera = new THREE.PerspectiveCamera(m, M.get_viewAspectRatio(), 10, 5e3), P.isPostProcessing) { P.composer = new THREE.EffectComposer(P.renderer); const r = new THREE.RenderPass(P.scene, P.camera); if (0 < P.taaLevel) { const a = new THREE.TAARenderPass(P.scene, P.camera);
                    a.unbiased = !1, P.composer.addPass(a), a.sampleLevel = P.taaLevel } var e;
                P.composer.addPass(r), 0 < P.taaLevel && (r.enabled = !1, e = new THREE.ShaderPass(THREE.CopyShader), P.composer.addPass(e)) }
            P.faceSlots = []; for (let e = 0; e < t; ++e) { const i = new THREE.Object3D; var o = new THREE.Object3D;
                i.frustumCulled = !1, i.visible = !1, i.matrixAutoUpdate = !1, i.add(o); let e = null;
                l.isComputeTorsoPose && (e = new THREE.Object3D, e.frustumCulled = !1, e.matrixAutoUpdate = !1, i.add(e)), P.faceSlots.push({ faceFollower: o, faceFollowerParent: i, torsoFollower: e }), P.scene.add(i) } var n;
            u.debugObjPoints && (n = l.solvePnPObjPointsPositions, Object.keys(n).forEach(function(e) { e = n[e]; const t = new THREE.Mesh(new THREE.BoxGeometry(3, 3, 3), new THREE.MeshBasicMaterial({ color: 16711680 }));
                t.position.fromArray(e), P.faceSlots[0].faceFollower.add(t) })), P.matMov = new THREE.Matrix4, P.matMov2 = new THREE.Matrix4, P.euler = new THREE.Euler, P.vec3 = new THREE.Vector3, P.preMatrix = (new THREE.Matrix4).makeRotationX(l.rxOffset), P.preMatrix.setPosition(0, l.translationYZ[0], l.translationYZ[1]), P.preMatrix.scale(new THREE.Vector3(1, 1, 1).multiplyScalar(l.scale)), M.update_threeCamera() }(t.maxFacesDetected), w(), T(l.solvePnPImgPointsLabels, l.solvePnPObjPointsPositions), l.callbackReady && (t.threeFaceFollowers = P.faceSlots.map(function(e) { return e.faceFollower }), t.threeTorsoFollowers = P.faceSlots.map(function(e) { return e.torsoFollower }), t.threeScene = P.scene, t.threeRenderer = P.renderer, t.threeComposer = P.composer, t.threeCamera = P.camera, l.callbackReady(e, t))) }

    function y(e) { i.viewport(0, 0, M.get_viewWidth(), M.get_viewHeight()), g && (i.useProgram(a.copyCrop.program), i.uniformMatrix2fv(a.copyCrop.uniforms.transformMat2, !1, f), i.activeTexture(i.TEXTURE0), i.bindTexture(i.TEXTURE_2D, c), i.drawElements(i.TRIANGLES, 3, i.UNSIGNED_SHORT, 0)); let t = null;
        t = e.length ? e.map(O) : O(e, 0), P.isPostProcessing ? P.composer.render() : P.renderer.render(P.scene, P.camera), l.callbackTrack && l.callbackTrack(e, t) }

    function O(e, t) { let o = null; const n = P.faceSlots[t]; return e.isDetected ? (o = null === r ? e.landmarks : (r[t] || (r[t] = TryOnStabilizer.instance(l.stabilizerSpec)), r[t].update(e.landmarks, M.get_viewWidthCSSPx(), M.get_viewHeightCSSPx(), e.s)), function(n, e) { var r = M.get_viewWidth() / 2,
                a = M.get_viewHeight() / 2,
                i = h.imgPointsPx;
            h.imgPointsLMIndices.forEach(function(e, t) { const o = i[t];
                o[0] = -n[e][0] * r, o[1] = -n[e][1] * a }); var t = h.objPoints,
                o = TRYONBOOTHDRAW.compute_pose(t, i, v[0], v[1]); if (o) { const s = P.matMov.elements;
                t = o.rotation, o = o.translation;
                s[12] = -o[0], s[13] = -o[1], s[14] = -o[2], s[0] = -t[0][0], s[4] = -t[0][1], s[8] = t[0][2], s[1] = -t[1][0], s[5] = -t[1][1], s[9] = t[1][2], s[2] = -t[2][0], s[6] = -t[2][1], s[10] = t[2][2], l.rotationContraints && function(e, t) { P.euler.setFromRotationMatrix(e, t.order), P.euler.set(t.rotXFactor * P.euler.x, t.rotYFactor * P.euler.y, t.rotZFactor * P.euler.z, t.order), P.matMov2.makeRotationFromEuler(P.euler), P.matMov2.copyPosition(e), e.copy(P.matMov2) }(P.matMov, l.rotationContraints), P.matMov.multiply(P.preMatrix), e.faceFollowerParent.matrix.copy(P.matMov), l.isCenterObjPoints && (t = h.objPointsMean, e.faceFollower.position.fromArray(t).multiplyScalar(-1)) } }(o, n), n.faceFollowerParent.visible = !0) : n.faceFollowerParent.visible && (n.faceFollowerParent.visible = !1, r && r[t] && r[t].reset()), l.isComputeTorsoPose && function(e, t) { const o = e.matrixWorld,
                n = P.euler;
            n.setFromRotationMatrix(o, "YZX"), n._x = l.torsoRotX, n._y *= l.torsoRotYFactor, n._z = 0, t.matrixWorld.makeRotationFromEuler(n); const r = P.vec3;
            r.fromArray(l.torsoBaseNeck), r.applyMatrix4(o), r.setY(r.y + l.torsoTranslateY), t.matrixWorld.setPosition(r), t.matrix.copy(t.parent.matrixWorld).invert().multiply(t.matrixWorld), t.updateWorldMatrix(!1, !0) }(n.faceFollowerParent, n.torsoFollower), o }

    function H(e) { e && (l.spec.videoSettings = { videoElement: e }), TRYONBOOTHDRAW.init(l.spec) } const M = { init: function(e) { l = Object.assign({ spec: {}, rxOffset: 0, translationYZ: [0, 0], scale: 1, isComputeTorsoPose: !1, torsoRotX: 0, torsoRotYFactor: .5, torsoBaseNeck: [0, -58, -18], torsoTranslateY: 70, solvePnPObjPointsPositions: o, solvePnPImgPointsLabels: n, isCenterObjPoints: !0, rotationContraints: null, stabilizerSpec: {}, canvasThree: null, isPostProcessing: !1, taaLevel: 0, callbackReady: null, callbackTrack: null, videoURL: null }, e); var t = { canvas: null, canvasId: "ARCanvas", NNCPath: "neuralNets/", callbackReady: b, callbackTrack: y }; if (l.spec = Object.assign({}, t, e.spec), null === l.spec.canvas && (l.spec.canvas = document.getElementById(l.spec.canvasId)), l.videoURL) { const r = document.createElement("video"); return r.setAttribute("src", l.videoURL), r.setAttribute("autoplay", !0), r.setAttribute("loop", !0), r.setAttribute("preload", !0), r.setAttribute("muted", "muted"), r.setAttribute("playsinline", !0), document.body.appendChild(r), r.style.maxWidth = "50vw", r.style.border = "1px solid red", new Promise(function(n, e) { r.oncanplay = function(e) { r.oncanplay = null; let t = !1;

                        function o() { r.play(), t || (r.style.display = "none", t = !0, H(r), n()) }
                        window.addEventListener("click", o), window.addEventListener("touchstart", o) } }) } return H(null) }, get_facePointPositions: function() { return l.solvePnPObjPointsPositions }, resize: function(e, t) { i && i.bindFramebuffer(i.FRAMEBUFFER, null), s.width = e, s.height = t, P.canvas.width = e, P.canvas.height = t, TRYONBOOTHDRAW.resize(), M.update_threeCamera(), P.composer && P.composer.setSize(e, t), w() }, add_occluder: function(e, t, o) { o = o || new THREE.Mesh; let n = null; if ("BufferGeometry" === e.type) n = e;
            else { if (!e.scene) throw new Error("Wrong occluder data format");
                e.scene.traverse(function(e) { if ("Mesh" === e.type) { if (null !== n && n !== e.geometry) throw new Error("The occluder should contain only one Geometry");
                        n = e.geometry } }) } let r = new THREE.ShaderMaterial({ vertexShader: THREE.ShaderLib.basic.vertexShader, fragmentShader: "precision lowp float;\n void main(void){\n gl_FragColor = vec4(1.,0.,0.,1.);\n }", uniforms: THREE.ShaderLib.basic.uniforms, side: THREE.DoubleSide, colorWrite: !1 });
            t && (n.computeVertexNormals(), r = new THREE.MeshNormalMaterial({ side: THREE.DoubleSide })), o.renderOrder = -1e12, o.material = r, o.geometry = n, o.userData.isOccluder = !0, P.faceSlots.forEach(function(e) { e.faceFollower.add(o.clone()) }) }, add_occluderFromFile: function(e, t, o, n) { const r = new THREE.Mesh; var a = e.split(".").pop().toUpperCase(); const i = { GLB: THREE.GLTFLoader, GLTF: THREE.GLTFLoader, JSON: THREE.BufferGeometryLoader }[a]; return new i(o).load(e, function(e) { void 0 !== t && t && t(r), M.add_occluder(e, n, r) }), r.scale.set(1.13, 1.13, 1.13), r }, get_sourceWidth: function() { return p.videoWidth }, get_sourceHeight: function() { return p.videoHeight }, get_viewWidthCSSPx: function() { return s.width / e }, get_viewHeightCSSPx: function() { return s.height / e }, get_viewWidth: function() { return s.width }, get_viewHeight: function() { return s.height }, get_viewAspectRatio: function() { return M.get_viewWidth() / M.get_viewHeight() }, set_isDrawVideo: function(e) { g = e }, update_solvePnP: function(e, t) { e && (l.solvePnPObjPointsPositions = Object.assign(l.solvePnPObjPointsPositions, e)), l.solvePnPImgPointsLabels = t || l.solvePnPImgPointsLabels, T(l.solvePnPImgPointsLabels, l.solvePnPObjPointsPositions) }, update_threeCamera: function() { const e = P.camera,
                t = P.renderer; var o = M.get_viewWidth(),
                n = M.get_viewHeight(),
                r = o / n,
                a = M.get_sourceWidth(),
                i = M.get_sourceHeight(),
                s = a / i,
                l = a < i ? 1 / s : 1; let c = u.cameraMinVideoDimFov * l;
            s < r && (a = i * (o / a), c = 2 * Math.atan(n / a * Math.tan(.5 * c * d)) / d), m = c, e.aspect = r, e.fov = c, e.updateProjectionMatrix(), t.setSize(o, n, !1), t.setViewport(0, 0, o, n) }, change_NN: function(e) { return TRYONBOOTHDRAW.update({ NNCPath: e }).then(function() { E.labels = TRYONBOOTHDRAW.get_LMLabels() }) }, reset_stabilizers: function() { r && r.length && r.forEach(function(e) { e.reset() }) }, getThree: function() { return P }, update_video: function(o) { return new Promise(function(t, e) { TRYONBOOTHDRAW.update_videoElement(o, function(e) { c = e, TRYONBOOTHDRAW.resize(), t() }) }) } }; return M }();
try { module.exports = TryOnHelper } catch (e) {}